---
layout: post
title: "类型混用引发的血案(C语言)"
date: 2014-12-21 21:01:12 +0800
categories: tech
---

# 案件

最近在看一个项目的时候，遇到了一段代码，去处掉一些不相关的东西以后，剩下的大概就是这些了吧。

    #include <stdio.h>
    int array[] = {1, 2, 3, 4, 5, 6, 7};
    #define LEN (sizeof(array) / sizeof(array[0]))
    
    int main(void)
    {
        int i, sum = 0;
        
        for(i = -1; i < LEN - 1; i++)
            sum += array[i+1];
        printf("%d\n", sum);
        
        return 0;
    }

执行效果是这个样子的：

    hdd@hdd:~/cprogram(master)$ ./a.out
    0
    
这个执行结果相当诡异，虽然循环的初始变量是-1，但是下面取数组元素的时候，也把i加上了1啊，理论上不会是这个结果啊。

<!--more-->

# 调查

任何诡异的事情必然就有原因，不能错过这样一个毁三观的机会。

## 锁定问题
N久没动手写过C语言，但是从-1开始赋值这种作死的写法，还是应该避免，所以我修改了一下循环，成了下面这个样子。

    for(i = 0; i < LEN; i++)
        sum += array[i]
        
运行结果是：

    hdd@hdd:~/cprogram(master)$ ./a.out
    28

居然对了！多运行了几次，结果都是对的，排除了程序其他部分的问题，就锁定在循环体本身或者是累加变量出错了。于是用gdb将断点打在了
    
    sum += array[i+1]
    
希望能够观察到运行过程中，局部变量sum的值的变化。

但是断点设置好了以后，执行运行，直接就执行完毕了，这个结果有点让人意外，但是还是说明了问题所在，**这个循环体根本就没有进去啊**！

## 尝试解释

既然现在知道了是循环体没有进去，那么问题就应该很简单了，要么就是循环变量初始化错了，要么就是循环条件出错了。

首先本着哪里复杂，哪里更有可能出错的基础上，怀疑循环条件出错了，因为这个循环条件里面，主要是牵涉到一个宏展开，而且两份代码，一个运行错误，一个运行正常，其中一个差异就是条件中是否是`LEN - 1`，于是我怀疑是宏展开的时候产生了歧义，因为宏展开是在预处理阶段做的，于是使用**`gcc -E`**，看了一下预处理以后的结果，省略去无关代码以后，只看展开后的循环体：

    for(i = -1; i < (sizeof(array) / sizeof(array[0])) - 1; i++)
        sum += array[i + 1];

看了一下，好像就是我们想要他表达的意思，当然代码很多问题是看不出来的，得运行，于是我在代码中加上了这样两行：

    int len = (sizeof(array) / sizeof(array[0])) - 1;
    printf("%d\n", len);

执行以后，准确的输出了6，完美的避开了我们的猜想。

那就只剩下最后一个可能性了，有人说的好。排除掉所有的可能性以后，最不可能的就是答案，那问题就出在了循环变量初始化上了，就是`i = -1`出错了。

可是问题到这里，我实在想不出有什么问题能让这句出错，一句简单的赋值。

## 求助

这个时候我求助了 @lyc 同学，事实证明，我问对人了，我给他运行了一下程序，他问了一句，这个LEN的展开结果，是有符号数还是无符号数啊？我恍然大悟，`sizeof`的返回值是`size_t`，而size_t从刚刚`gcc -E`中这句可以看出类型：

    typedef long unsigned int size_t;
    
是一个无符号整数。

## 结论

这样子，问题就清晰了，**因为sizeof返回的是无符号数，所以LEN是一个无符号数，当无符号数和-1做<操作的时候，根据类型转换规则，会将-1转换成对应的无符号数，因为机器码中-1最高位是1，当按照无符号数解释的时候，就相当大了，所以<返回False，循环体不会执行**


# 刨根

本着死磕到底的决心，我决定弄明白c语言的类型转换规则，于是参考了《一站式学习C编程》中的这部分内容

## 数据类型系统

首先为了弄明白这个问题，得弄明白的另外一个问题是C语言中的基本数据类型，首先申明，由于不同体系结构之间的差异，这里默认讲的是x86/Linux/gcc。

### 整型

在C语言中char型占了一个字节的存储空间，一个字节通常是8个bit，如果按照无符号数来解释，就是0~255， 如果按照有符号来解释，就是-128~127。C语言规定了signed和unsigned两个关键字来表示是否是无符号数。

那么常用的char是无符号还是有符号呢？在C标准中规定是`Implementation Defined`，设么意思呢，就是编译器在实现的时候，可以按照是无符号，也可以按照是有符号，在不同平台上，那种效率高，就采用哪种实现，但是具体的实现方式，需要在文档中明确写出。这里面提到的Implementation Define还有Unspecifiled、Undefined这三种的区别，后续会用一篇文章来讲，这里仅仅是提到一下。

除了char以外，整型还包括short int、int、long int、long long int等，每种都可以加上signed和unsigned修饰。

### 浮点数

C标准中规定的浮点型有float、double、long double

## 类型转换

简单的讲完了类型以后，就可以讲一下类型转换规则了。

### Interger Promotion

这条转换规则规定：

*    在一个表达式中，凡是可以使用int和unsigned int作为右值的，也都可以使用有符号和无符号的char型、short型和Bit-filed。
*    如果原始类型的取值范围都能用int型表示，则类型被提升为int，如果表示不了，则提升为unsigned int

主要适用于以下情况：

*    如果函数的形参类型未知，比如Old Style C的函数声明，或者参数列表中有...
*    算数运算中的类型转换。有符号和无符号的char、short和Bit-filed做算数运算的时候

### Usual Arithmetic Conversion

这条规则规定，连个算数类型的操作数做算数运算，如果两边操作数的类型不同，编译器自动做类型转换，是的两边类型相同之后，再继续运算。转换规则如下：

*    如果一边的类型是long double，则把另外一边也转换成long double
*    否则，如果一边的类型是double，则把另外一边也转成double
*    否则，如果有一边是float，则把另外一边也转换成float
*    否则，两边都是整数的话，按照Integer Promotion做类型转换

如果类型还是不相同，则需要继续转换，我们规定char、short、int、long、long long的转换级别一个比一个高，相同类型的unsigned和signed具有相同rank，则继续转换规则如下：

*    如果两边都是有符号的，或者都是无符号的，那么脚底rank转换成较高rank
*    否则，如果一边是无符号，一边有符号，且无符号的rank不低于有符号的rank，则把有符号转换成无符号类型
*    否则，一边有符号，一边无符号，且无符号的rank低于有符号rank。如果有符号类型可以覆盖这个无符号数的取值，则把无符号数转换成有符号数的类型
*    否则，则把两边都转成有符号数的rank对应的无符号类型

### 赋值操作

除了算数运算，在赋值或者初始化时，等号两边的类型不相同，则编译器会把等号右边的类型，转换成等号左边的类型，再赋值。

这个规则比较简单，但是这里面有两个很容易被忽略的情况。函数调用传参的过程，相当于定义形参，并且用实参对形参初始化，函数的返回过程，相当于定义一个临时变量，并且用return的表达式对其初始化，所以上述规则也适用于这两种情况。

### 强制类型转换

除了上面讲到三种称为隐式转换规则，我们自己也可以通过类型转换运算符，规定某个表达式的类型


以上，洋洋洒洒的把类型转换的基本规则差不多写完了，但是给人的感觉就是复杂的令人发指。越是复杂的东西，就越是很难凭借记忆去掌握，所以上面的转换规则我觉得干脆不需要掌握，只是让自己知道，类型之间的混用会很麻烦很容易引发我们开篇讲到的bug，所以需要的是尽量避免，并且在程序出错的时候能够想起来从这上面找到原因，就OK了。

好了，就先扯这么多了，最后感谢 @lyc 的帮助，宋劲彬先生的《一站式学习C编程》以及 @雨痕老师 的推荐
